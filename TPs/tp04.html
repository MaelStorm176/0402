<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" /><title>Info0402 : TP N°4</title>

</head>
<body>
<h1>Info0402 TP N°4 : tableau d'objets, polymorphisme, héritage
et virtualité</h1>

Le but de ce TP est d'obtenir une hiérarchie qui ressemble à ceci:<br /><div style="text-align: center;"><img style="width: 747px; height: 498px;" alt="Hierarchie1" src="tp06-1.png" /></div>


<h2>Préambule: classe Curve</h2>
De manière similaire à ce que l'on avait fait pour la classe Surface,
on peut définir une classe Curve qui sert à représenter des courbes.
Elle hérite aussi de Geom2D, et d'une classe Stroke contenant la
couleur du trait.

<h2>Partie 1: stockage d'un tableau de points</h2>
<p>On ajoute les classes de stockage suivantes:</p>
<ul>
<li>une classe PointsArray qui stocke et gère un tableau de
points de taille fixe (l'ajout de points supplémentaires n'est pas
possible), </li>
<li>une classe ReallocatablePointsArray qui hérite de
PointsArray et qui permet de rendre le tableau de points réallouable
(l'ajout de points supplémentaire est possible). </li>
<li>ces classes devront implémenter la construction et
l'assignation par copie, </li>
<li>la translation, changement d'échelle et la rotation devront
être implémentés, </li>
<li>trois constructeurs devront être disponibles: à partir de
la taille de l'allocation (= nombre fixe de sommets&nbsp;ensuite
pour PointsArray), à partir d'une liste de points (une
initializer_list&lt;Point&gt;, voir en annexe ci-dessous), et à partir de: un nombre de points n, un centre c et une taille s
qui initialise une liste de n points régulièrement répartis sur un
cercle de centre c et de rayon r (à savoir les points Pi du PointsArray
sont Pi(x,y) = c + r * ( cos[theta(i)], sin[theta(i)] ) où theta(i)
=2.pi/n*i et i est dans {0,1,...,n-1}). </li>
</ul>
<ol>
<li>Ecrire la définition des classes PointsArray et
ReallocatablePointsArray. </li>
<li>Ecrire les transformations: la position des points devra
être modifiée dans la classe de stockage. Ces opérations ont
généralement besoin du centre de l'objet: il sera calculé comme le
barycentre de l'ensemble des points dans un Polypoints. Pour la
translation, effectue une translation de tous les points. Pour la
rotation,&nbsp;effectue la rotation des points autour de ce
barycentre. Pour la rotation, on rappelle qu'une rotation de centre
(0,0) et d'angle t s'écrit (x',y')=R(x,y)=( x.cos(t) - y.sin(t) ,
x.sin(t) + y.cos(t) ). En conséquence, une rotation d'angle t et de
centre c=(cx,cy) s'écrit (x',y')=(cx,cy) + R(x-cx,y-cy). Pour le
changement d'échelle, effectue un changement d'échelle s centrée en c,
à savoir (x',y') = S(x,y) = ( cx + s.(x-cx), cy + s.(y-cy) ).</li>
<li>Ajouter une classe Polygon qui représente un polygone telle
qu'elle hérite de Surface et de&nbsp;ReallocatablePointsArray.</li>
<li>Redéfinir la triangle telle qu'elle hérite&nbsp;de
Surface et de&nbsp;PointsArray.</li>
<li>Ajouter une classe Polyline qui représente une ligne
polygonale telle qu'elle hérite au moins de Curve
et de&nbsp;ReallocatablePointsArray.</li>
</ol>
<h2>Partie 2: manipulations d'objets géométriques</h2>
<p>On veut maintenant utiliser les objets issus de TP précédent
afin de créer des figures (= composition d'ensemble d'objets
géométriques).</p>
<ol>
<li>Créer une classe Figure qui représente une collections
d'objets géométriques (=tableau de Geom2D*) permettant l'insertion ou la suppression. </li>
<li>Ajouter l'accès à n'importe quel objet de la collection en
surchargeant l'opérateur[].</li>
<li>Ajouter la méthode Info qui permet d'afficher la liste
complète des éléments contenus dans la collection.</li>
<li>Ajouter une méthode permettant d'appliquer une
transformation à l'ensemble des objets de la collection.</li>
<li>Ajouter à cette classe la possibilité d'écrire dans un
fichier svg l'ensemble des objets contenus dans la collection.</li>
<li>Ecrire un code d'exemple utilisant cette classe. L'ensemble
des Surfaces et des Courbes définis devra permettre de générer un
fichier svg qui sera intégré au fichier TP4.html.</li>
</ol>
<h2>Annexe</h2>
<div style="margin-left: 40px;">En C++11, si l'on inclut
le module
&lt;initializer_list&gt;, on peut écrire un constructeur
monvecteur(const initializer_list&lt;int&gt; list) permettant de
passer en paramètre une liste {4, 10, 12, 43} à un constructeur.
L'écriture du code du constructeur est alors de la forme suivante.
Ajouter ce constructeur à votre structure.
<table style="height: 152px; width: 689px; text-align: left;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td style="background-color: rgb(204, 204, 204);">monvecteur(const
std::initializer_list<INT>&lt;int&gt; &amp;list) {</INT><br />
<INT></INT>
<INT></INT>&nbsp; &nbsp; &nbsp;//
list.size()
retourne le nombre d'élément dans la liste<br />
<INT>&nbsp; &nbsp; &nbsp;// mettre ici
l'initialisation des champs/allocation <br />
&nbsp; &nbsp; &nbsp;// le code ci-dessous insère les
éléments de la liste dans l'ensemble<br />
&nbsp; &nbsp; &nbsp;for(auto &amp;i : list) // utiliser ici l'élément i de la liste<br />
} </INT></td>
</tr>
</tbody>
</table>
</div>
<span style="font-size: 10px;">Année
universitaire 2018-2019 : version du 7 février 2019.</span>
</body></html>
